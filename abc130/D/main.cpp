#include<iostream>
#include<string>
#include<algorithm>
#include<vector>
#include<iomanip>
#include<math.h>
#include<complex>
#include<queue>
#include<deque>
#include<stack>
#include<map>
#include<set>
#include<bitset>
#include<functional>
#include<assert.h>
#include<numeric>
using namespace std;
#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )
#define rep(i,n) REP(i,0,n)
using ll = long long;
const int inf=1e9+7;
const ll longinf=1LL<<60 ;
const ll mod=1e9+7 ;

vector<ll> a;

// https://qiita.com/drken/items/97e37dd6143e33a64c8c#2-%E4%B8%80%E8%88%AC%E5%8C%96%E3%81%97%E3%81%9F%E4%BA%8C%E5%88%86%E6%8E%A2%E7%B4%A2%E6%B3%95
// 引用
bool isOK(ll index, ll key, ll ruisekiwa) {
    if (a[index] - ruisekiwa >= key) return true;
    else return false;
}

// 汎用的な二分探索のテンプレ
ll binary_search(ll key, ll ruisekiwa) {
    ll left = -1; //「index = 0」が条件を満たすこともあるので、初期値は -1
    ll right = (ll)a.size(); // 「index = a.size()-1」が条件を満たさないこともあるので、初期値は a.size()

    /* どんな二分探索でもここの書き方を変えずにできる！ */
    while (right - left > 1) {
        ll mid = left + (right - left) / 2;

        if (isOK(mid, key, ruisekiwa)) right = mid;
        else left = mid;
    }

    /* left は条件を満たさない最大の値、right は条件を満たす最小の値になっている */
    return right;
}


void solve(long long N, long long K, std::vector<long long> ary){
    // cout << "hello" << endl;
    rep(i, N) {
        if (i==0) {
            a.push_back(ary[i]);
        }
        else
        {
            a.push_back(a[i-1] + ary[i]);
        }
    }
    ll count = 0;
    rep(i,N) {
        ll tmpx;
        if (i==0) {
            tmpx = binary_search(K, 0); 
        }
        else
        {
            tmpx = binary_search(K, a[i-1]);
        }
        
        if (tmpx != N) {
            count += N-tmpx;
        }
        // cout << i << " " << tmpx << " " << count << endl;
    }
    cout << count << endl;

}

// Generated by 1.1.4 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
int main(){
    long long N;
    scanf("%lld",&N);
    long long K;
    scanf("%lld",&K);
    std::vector<long long> ary(N);
    for(int i = 0 ; i < N ; i++){
        scanf("%lld",&ary[i]);
    }
    solve(N, K, std::move(ary));
    // return 0;
}
